use std::fs;
use std::env;
use std::process::{Command, Stdio};


fn tail_file(){
    for file in fs::read_dir("./dirb").unwrap(){
        println!("{}", file.unwrap().path().display())
    }
    let mut filename = String::new();
    println!("name of the file to watch?");
    std::io::stdin().read_line(&mut filename).expect("error reading filename selection");
    let filename = format!("./dirb/{}",filename);
    Command::new("kitty").arg("tail").arg("-f").arg(filename).spawn().expect("error spawning tail window");
}

fn kill_all_dirbs(){
    Command::new("killall").arg("dirb").spawn().expect("error killing");
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3{
        print!("
USAGE:
multidirb /path/to/urls.txt /path/to/wordlist
        ")
    }
    else{
        let text = fs::read_to_string(&args[1]).expect("error reading urls file");
        fs::create_dir("./dirb").expect("error creating folder");
        let lines: Vec<&str> = text.split("\n").collect();
        let mut process_count = 0;
        for line in lines{
            let words: Vec<&str> = line.split(" ").collect();
            for word in words{
                if word.contains("http"){
                    let url = word;
                    let word_vec: Vec<&str> = word.split("/").collect();
                    let filename = format!("./dirb/{}",word_vec[2]);
                    let outfile = fs::File::create(filename).expect("error creating output file");
                    let command_output = Stdio::from(outfile);
                    Command::new("dirb").arg(url).arg(&args[2]).stdout(command_output).spawn().expect("error running dirb command");
                    process_count = process_count +1;
                }
            }
        }
       /* let option_loop = true;
        while option_loop{
            let mut option = String::new();
            print!("
    {} processes created
    1.) exit leaving processes running
    2.) exit killing all processes
    3.) watch an output file
        ", process_count);
        std::io::stdin().read_line(&mut option).expect("error reading option selection");
            match option.as_str(){
                "1\n" =>  {break},
                "2\n" => {kill_all_dirbs(); break},
                "3\n" => tail_file(),
                _=>println!("unknown option"),
            }
        }*/
    }
}